<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Ivan Hetman" />
  <title>Steiner systems S(2,6,121/126), S(2,7,169) based on difference families</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    div.abstract {
      margin: 2em 2em 2em 2em;
      text-align: left;
      font-size: 85%;
    }
    div.abstract-title {
      font-weight: bold;
      text-align: center;
      padding: 0;
      margin-bottom: 0.5em;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Steiner systems S(2,6,121/126), S(2,7,169) based on
difference families</h1>
<p class="author">Ivan Hetman</p>
<p class="date">January 2024</p>
<div class="abstract">
<div class="abstract-title">Abstract</div>
<p>In this paper new Steiner systems <span
class="math inline"><em>S</em>(2,6,121)</span>, <span
class="math inline"><em>S</em>(2,6,126)</span>, <span
class="math inline"><em>S</em>(2,7,169)</span> are introduced. Also some
non-existence results for line lengths <span
class="math inline">7..11</span> are presented. There is no solid proof
that presented algorithm is exhaustive or correct, but it produces same
results on already known difference families for line lengths <span
class="math inline">3..6</span>. Due to calculation-based approach this
paper probably won’t be published, but will be submitted to arxiv as it
contains some new results.</p>
</div>
</header>
<h1 id="introduction">Introduction</h1>
<p>There exist enumerations for non-isomorphic difference families in
<span class="citation" data-cites="HoCD"></span> and <span
class="citation" data-cites="BaiTop"></span>. According to this results,
number of non-isomorphic <span
class="math inline">(<em>v</em>,<em>k</em>,1)</span> difference families
are known for <span class="math inline"><em>k</em> = 3</span> and <span
class="math inline"><em>v</em> ≤ 61</span>, <span
class="math inline"><em>k</em> = 4</span> and <span
class="math inline"><em>v</em> ≤ 76</span>, <span
class="math inline"><em>k</em> = 5</span> and <span
class="math inline"><em>v</em> ≤ 85</span>, <span
class="math inline"><em>k</em> = 6</span> and <span
class="math inline"><em>v</em> ≤ 96</span> and <span
class="math inline"><em>k</em> = 7</span> and <span
class="math inline"><em>v</em> ≤ 91</span>. Every difference family
produces balanced incomplete block design <span
class="math inline"><em>B</em><em>I</em><em>B</em><em>D</em>(<em>v</em>,<em>k</em>,<em>λ</em>)</span>.
Number of BIBD is significantly larger than the family of difference
families with same parameters. Still, in <span class="citation"
data-cites="HoCD"></span> only 1 non-isomorphic <span
class="math inline"><em>B</em><em>I</em><em>B</em><em>D</em>(121,6,1)</span>
is known and only 2 non-isomorphic <span
class="math inline"><em>B</em><em>I</em><em>B</em><em>D</em>(126,6,1)</span>.</p>
<h1 id="algorithm-description">Algorithm description</h1>
<p>We will construct base blocks over <span
class="math inline">ℤ<sub><em>v</em></sub></span> one by one. Blocks are
lexicographically ordered. If <span
class="math inline"><em>k</em>|<em>v</em></span> then last block is
always <span
class="math inline">(0,<em>k</em>,2<em>k</em>,...,(<em>v</em>−<em>k</em>))</span>.
First item of block is always <span class="math inline">0</span>, second
item of block should produce maximal difference between two consecutive
members of the block (including last and first = 0). Then on from second
to last block we iterate limited possible numbers. Also we have filter
which contains "forbidden" numbers which will make construction of
difference family impossible. If specific block produces same difference
<span
class="math inline"><em>Δ</em><em>B</em> = {<em>b</em><sub><em>i</em></sub> − <em>b</em><sub><em>j</em></sub>|<em>i</em>, <em>j</em> = 1, ..., <em>k</em>; <em>i</em> ≠ <em>j</em>}</span>
as already computed, we filter it out because it will just repeat same
calculation. In the end we add filtered difference family to the final
list by "mirroring" procedure.</p>
<p>Difference family search algorithm is easily parallelizable by second
number in first block. This fact helps to utilize modern multi-core
hardware. Search was run on 24-core PC. Simple parallelization of the
algorithm led to 10x performance boost. Code is present <span
class="citation" data-cites="code"></span> here.</p>
<p>Let’s consider <span class="math inline"><em>v</em> = 15</span> and
<span class="math inline"><em>k</em> = 3</span>. As <span
class="math inline">3|15</span>, then we automatically have the last
block <span class="math inline">(0,5,10)</span>. Let’s calculate first
two blocks. After the search using base algorithm, we obtain first block
<span class="math inline">(0,7,9)</span>. Second block is then <span
class="math inline">(0,11,12)</span>. We see that this two blocks form
difference family with <span class="math inline">(0,5,10)</span>.
Therefore it’s desired difference family. As we limited first step by
selecting only unique differences, we need to conduct "mirroring"
procedure. To mirror any block, we fix first two numbers <span
class="math inline"><em>b</em><sub>1</sub> = 0</span> and <span
class="math inline"><em>b</em><sub>2</sub></span>, and apply
transformation <span
class="math inline"><em>b</em><sub><em>i</em></sub> → <em>b</em><sub>1</sub> + (<em>v</em>−<em>b</em><sub><em>i</em></sub>)</span>
to the rest. For instance, "mirror" of <span
class="math inline">(0,7,9)</span> is <span
class="math inline">(0,7,13)</span> and "mirror" of <span
class="math inline">(0,11,12)</span> is <span
class="math inline">(0,11,14)</span>. If we mirror all blocks
simultaneously it can be easily seen that obtained difference families
are isomorphic. So, we need to conduct <span
class="math inline">$2^{\lfloor\frac{v}{k(k-1)}\rfloor - 1}$</span>
different mirrorings to obtain all possibly non-isomorphic difference
families. In the end we filter out isomorphic difference families. For
<span class="math inline"><em>v</em> = 15</span> and <span
class="math inline"><em>k</em> = 3</span> nothing is filtered, but for
<span class="math inline"><em>v</em> = 13</span> and <span
class="math inline"><em>k</em> = 3</span>, two difference families
obtained by mirroring are isomorphic.</p>
<h1 id="results">Results</h1>
<p>Applying described algorithm gives us same numbers that are in <span
class="citation" data-cites="HoCD"></span> for known difference
families. Still, number of non-isomorphic difference families for <span
class="math inline"><em>v</em> = 73</span> and <span
class="math inline"><em>k</em> = 4</span> in <span class="citation"
data-cites="BaiTop"></span> is <span class="math inline">1426986</span>.
But same calculation using algorithm described above gives us <span
class="math inline">1428546 &gt; 1426986</span> number.</p>
<p>Also using same algorithm it was possible to get some other
low-hanging fruits. In addition to <span class="citation"
data-cites="BaiTop1"></span> result of non-existence of <span
class="math inline">(127,7,1)</span> difference family, it was
established non-existence of <span class="math inline">(133,7,1)</span>,
<span class="math inline">(113,8,1)</span>, <span
class="math inline">(120,8,1)</span>, <span
class="math inline">(145,9,1)</span>, <span
class="math inline">(153,9,1)</span>, (Update December 2024) <span
class="math inline">(169,8,1)</span>, (Update December 2024) <span
class="math inline">(176,8,1)</span>, (Update December 2024) <span
class="math inline">(181,10,1)</span>, (Update December 2024) <span
class="math inline">(190,10,1)</span> and (Update December 2024) <span
class="math inline">(231,11,1)</span>, (Update March 2025) <span
class="math inline">(175,7,1)</span> difference families.</p>
<div class="example">
<p><em>Example 1</em>. Exhaustive list of difference families <span
class="math inline">(121,6,1)</span>. "Mirrorings" of any of the sets
produce 8 non-isomorphic difference family yielding 48
multiplier-nonisomorphic difference families.</p>
<ul>
<li><p>{{0, 25, 37, 55, 76, 99}, {0, 52, 57, 72, 110, 113}, {0, 54, 71,
81, 90, 97}, {0, 73, 75, 79, 107, 108}}</p></li>
<li><p>{{0, 25, 45, 66, 79, 97}, {0, 39, 46, 51, 83, 99}, {0, 62, 63,
65, 71, 98}, {0, 64, 74, 78, 93, 104}}</p></li>
<li><p>{{0, 26, 35, 54, 72, 97}, {0, 40, 47, 52, 91, 113}, {0, 42, 53,
57, 63, 80}, {0, 56, 76, 89, 90, 92}}</p></li>
<li><p>{{0, 26, 41, 53, 73, 96}, {0, 50, 52, 87, 111, 117}, {0, 63, 72,
77, 105, 108}, {0, 64, 75, 82, 83, 104}}</p></li>
<li><p>{{0, 29, 31, 56, 80, 93}, {0, 40, 46, 50, 66, 98}, {0, 45, 60,
67, 78, 79}, {0, 47, 68, 77, 82, 85}}</p></li>
<li><p>{{0, 38, 39, 56, 61, 85}, {0, 45, 51, 58, 66, 78}, {0, 49, 53,
79, 90, 93}, {0, 52, 54, 86, 102, 111}}</p></li>
</ul>
</div>
<div class="example">
<p><em>Example 2</em>. Exhaustive list of difference families <span
class="math inline">(126,6,1)</span>. "Mirrorings" of any of the sets
produce 8 non-isomorphic difference family yielding 64
multiplier-nonisomorphic difference families. Last block <span
class="math inline">{0, 21, 42, 63, 84, 105}</span> is omitted.</p>
<ul>
<li><p>{{0, 26, 38, 56, 81, 103}, {0, 40, 48, 68, 99, 102}, {0, 41, 57,
93, 94, 107}, {0, 80, 82, 87, 91, 97}}</p></li>
<li><p>{{0, 28, 46, 68, 85, 101}, {0, 45, 52, 65, 95, 99}, {0, 49, 59,
64, 78, 115}, {0, 82, 88, 90, 91, 114}}</p></li>
<li><p>{{0, 30, 50, 69, 95, 123}, {0, 34, 59, 77, 82, 94}, {0, 64, 68,
79, 119, 120}, {0, 80, 88, 90, 104, 117}}</p></li>
<li><p>{{0, 35, 36, 64, 89, 103}, {0, 44, 60, 70, 77, 92}, {0, 55, 57,
61, 102, 107}, {0, 75, 83, 86, 95, 113}}</p></li>
<li><p>{{0, 36, 37, 47, 77, 108}, {0, 38, 52, 64, 91, 97}, {0, 46, 50,
66, 69, 94}, {0, 68, 70, 75, 83, 92}}</p></li>
<li><p>{{0, 36, 37, 64, 93, 115}, {0, 45, 52, 83, 106, 118}, {0, 67, 71,
77, 101, 117}, {0, 68, 82, 85, 87, 100}}</p></li>
<li><p>{{0, 36, 38, 48, 75, 95}, {0, 52, 68, 81, 82, 86}, {0, 53, 62,
70, 77, 103}, {0, 55, 61, 80, 83, 115}}</p></li>
<li><p>{{0, 47, 48, 67, 91, 123}, {0, 49, 66, 74, 111, 120}, {0, 57, 61,
68, 90, 95}, {0, 73, 85, 87, 103, 113}}</p></li>
</ul>
</div>
<div class="example">
<p><em>Example 3</em>. By exhaustive search finished in April 2025, I
managed to find all difference families for <span
class="math inline">(169,7,1)</span>. All of them are obtained from one
base family by mirrorings. Two of them have 3 multiplier automorphisms.
Here is list of them together with multiplier automorphism count. <span
class="math display">1 : {{0, 1, 3, 11, 48, 65, 83}, {0, 4, 13, 29, 43, 81, 141}, {0, 5, 12, 36, 56, 78, 111}, {0, 6, 21, 40, 67, 90, 116}}</span>
<span
class="math display">1 : {{0, 1, 3, 11, 48, 65, 83}, {0, 4, 13, 29, 43, 81, 141}, {0, 5, 12, 36, 56, 78, 111}, {0, 6, 59, 85, 108, 135, 154}}</span>
<span
class="math display">3 : {{0, 1, 3, 11, 48, 65, 83}, {0, 4, 13, 29, 43, 81, 141}, {0, 5, 63, 96, 118, 138, 162}, {0, 6, 21, 40, 67, 90, 116}}</span>
<span
class="math display">3 : {{0, 1, 3, 11, 48, 65, 83}, {0, 4, 32, 92, 130, 144, 160}, {0, 5, 63, 96, 118, 138, 162}, {0, 6, 21, 40, 67, 90, 116}}</span></p>
</div>
<h1 id="acknowledgement">Acknowledgement</h1>
<p>I would like to express my thanks to Roman Obukhivskyi who suggested
better implementation for one of time-consuming algorithm parts, so it
increased my algorithm speed 3-5 times and allowed to finish <span
class="math inline">(175,7,1)</span> and <span
class="math inline">(169,7,1)</span> on my home PC in acceptable amount
of time (approximately a month).</p>
<h1 id="data">Data</h1>
<p><a href="data/151-6.txt">Raw data</a></p>
<div class="thebibliography">
<p>C. J. Coulborn, J. H. Dinitz <span><em>Handbook of Combinatorial
Designs, Second Edition</em></span>, 2007.</p>
<p>Baicheva T., Topalova S. <span><em>Classification results for (v, k,
1) cyclic difference families with small parameters</em></span>. In:
Deza M., Petitjean M., Markov K. (eds.) Mathematics of Distances and
Applications, pp. 24—30. International Book Series: Information Science
and Computing, Book 25ITHEA Publication, Sofia</p>
<p>Baicheva T., Topalova S. <span><em>Classification of optimal (v, k,
1) binary cyclically permutable constant weight codes with k=5, 6 and 7
and small lengths</em></span>. Des. Codes Cryptogr. 87, 365–374 (2019).
https://doi.org/10.1007/s10623-018-0534-x</p>
<p><a
href="https://github.com/Ihromant/math-utils/blob/44bf2c6964a4f70c3349859b6b75ef2fe486ab7a/src/test/java/ua/ihromant/mathutils/BibdFinder1Test.java">Github
repository</a>, 2023.</p>
</div>
</body>
</html>
